{
  "hash": "e625fd5f1e9518b2eeda654256a99562",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Exploring, arrange, count\nengine: knitr\nformat: live-html\nwebr:\n  packages:\n    - readr\n    - dplyr\n    - lubridate\n    - gradethis\nresources:\n  - images\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n::: {.cell}\n```{webr}\n#| include: false\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nfloods <- df |> filter(incidentType==\"Flood\")\nfloods_adjusted <- floods |> \n  mutate(year=year(declarationDate))\nfloods_match <- floods_adjusted |> \n  mutate(year_match=\n           case_when(year==fyDeclared ~ \"Match\",\n                     TRUE ~ \"Not a match\"\n  )) |> \n  group_by(year_match) |> \n  summarize(total=n())\nfloods_match_count <- floods_match |> \n  filter(year_match==\"Not a match\") |> \n  pull(total)\n```\n:::\n\n::: {.cell edit='false' define='ok_reponse'}\n```{webr}\n#| edit: false\n#| output: false\n#| define:\n#|   - ok_reponse\nlibrary(htmltools)\nok_reponse <- function(reponse, n) {\n  if (is.na(reponse)) HTML(\"\")\n  else if (reponse == n) div(HTML(\"Correct ✓\"), style = \"color: green\")\n  else div(HTML(\"Incorrect ✗\"), style = \"color: red\")\n}\n```\n:::\n\n\n\n\n## Intro\n\n\nIn this lesson, we're going to start exploring data with the package **dplyr.**\n\n* It's designed to work with data frames, which is what journalists are used to\n* Great for data exploration and transformation\n* Intuitive to write and easy to read, especially when using the “chaining” syntax of pipes\n\nThese are the functions/data analysis verbs we'll be going over:\n\n* filter()\n* select()\n* arrange()\n* mutate()\n* summarize() plus group_by()\n\nFirst, let's bring in the data.\n\n## Importing\n\n**We're going to play around with historical FEMA disaster declaration data.**\n\nFirst steps when analyzing data in R.\n\nBring in the appropriate packages.\n\nLet's start out with **tidyverse** which is a suite of packages that are consistently used to import, wrangle, and visualize data. It's one package that installs, like nearly a dozen other ones such as **readr**, **dplyr**, **tidyr** and **ggplot2**. The **lubridate** package is for dealing with dates.\n\nAnd we'll also need to bring the data in. \n\nYou can download it and import it locally, but if it's a csv, you can just link to it and R will download it for you in the function.\n\nUse the function from the **readr** package to import the csv from the URL. (This will take several moments to download, it's a big file)\n\n\n\n::: {.panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='ea1'}\n```{webr}\n#| exercise: ea1\nlibrary(dplyr)\nlibrary(readr)\nlibrary(lubridate)\n\n#https://www.fema.gov/openfema-data-page/disaster-declarations-summaries-v2\ndf <- ________(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n```\n:::\n\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"ea1\"}\n\nfunction starts with an *r*.\ntwo words separated with a \"_\"\n\n:::\n\n## Solution\n\n::: { .solution exercise=\"ea1\"}\n\n\n\n\n\n::: {.cell exercise='ea1' solution='true'}\n```{webr}\n#| exercise: ea1\n#| solution: true\nlibrary(dplyr)\nlibrary(readr)\nlibrary(lubridate)\n\n#https://www.fema.gov/openfema-data-page/disaster-declarations-summaries-v2\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n```\n:::\n\n::: {.cell exercise='ea1' check='true'}\n```{webr}\n#| exercise: ea1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n:::\n\n:::::\n\n\n## Exploring steps\n\nWhat to do when you first get a data set? Poke around and see what you're working with.\n\nUse the function on the **df** object you imported into your R environment.\n\nWe want to look at all the columns available to work with in the data. In Excel, you could just open up the file and click and scroll around but this time we want to do it within the R environment.\n\n\n::: {.panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='glimpse'}\n```{webr}\n#| exercise: glimpse\n________df_\n```\n:::\n\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"glimpse\"}\nStarts with a *g*\nAlso, don't forget that functions need parentheses.\n:::\n\n## Solution\n\n::: { .solution exercise=\"glimpse\"}\n\n\n\n\n::: {.cell exercise='glimpse' solution='true'}\n```{webr}\n#| exercise: glimpse\n#| solution: true\nglimpse(df)\n```\n:::\n\n::: {.cell exercise='glimpse' check='true'}\n```{webr}\n#| exercise: glimpse\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n\n:::\n\n::::\n\n\n## Range\n\nAlright, we know that there are 28 different columns and more than 67,000 rows (each one a different disaster declaration) in this data set. That's a lot to work with!\n\nWe also see in the `<>` what type of data is within each of the columns (you can't mix).\n\n* `<chr>` for characters or strings\n* `<dbl>` for numbers\n* `<dttm>` for date times\n\nSo `glimpse()` only gave us a sample of the first few values in each column. \n\nNext, we can drill down into individual columns we're interested in.\n\n**incidentBeginDate** could be useful if we want to track incidents overtime.\n\nWe should check how far back and how recent the incidents are.\n\nUse a function on the **df** object to determine the range of dates for incidents.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='range'}\n```{webr}\n#| exercise: range\n_____df_incidentBeginDate_\n```\n:::\n\n\n\n\n## Hint\n::: { .hint excerise=\"range}\nfunction starts with an *r*.\nAlso, in Base R, to focus on a single column in a data frame, \nyou need a dollar sign between the data frame name and column name\n:::\n\n## Solution\n\n::: { .solution exercise=\"range\"}\n\n\n\n::: {.cell exercise='range' solution='true'}\n```{webr}\n#| exercise: range\n#| solution: true\nrange(df$incidentBeginDate)\n```\n:::\n\n::: {.cell exercise='range' check='true'}\n```{webr}\n#| exercise: range\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n::::\n\n## Table\n\nDid any other columns catch your eye?\n\nHopefully **incidentType** did. \n\nLet's next get a sense of what type of disasters are listed in this data set.\n\nIn Base R, the quick way to do this is to use the function `table()` around a column and data frame.\n\nTry using the function below on the column `incidentType`\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='types'}\n```{webr}\n#| exercise: types\n### Using base R\ntable(df_____________)\n\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"types\"}\nIn Base R, you need a special character between the data frame name and column name\n:::\n\n## Solution\n\n::: { .solution exercise=\"types\"}\n\n\n\n::: {.cell exercise='types' solution='true'}\n```{webr}\n#| exercise: types\n#| solution: true\ntable(df$incidentType)\n```\n:::\n\n::: {.cell exercise='types' check='true'}\n```{webr}\n#| exercise: types\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n\n:::\n::::\n\n## Count\n\nAlright, you can see Biological, Chemical, Coastal Storm, etc...\n\nIt might take sometime to figure out which is the most... Since it's ordered alphabetical.\n\nSo `table()` is a quick exploratory command from Base R but if you want to save it as a dataframe, then the **dplyr** method is better. \n\nUse the `count()` function on **df**. Because we're using a function from the **dplyr** library, which is part of the tidyverse suite of packages, then we don't need to use a `$` to focus on the specific column `incidentType`.\n\nThe function is structured so that the first argument in the function is always the data frame and second one is the column in the data frame, separated with a comma.\n\nTry the `count()` function here on the `incidentType` column of **df**.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='count'}\n```{webr}\n#| exercise: count\nincident_types <- _____(df, _________)\n\nincident_types\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"count\"}\nThese are how tidy functions are structured:\nfunction_name(dataframe_name, column_name)\n:::\n\n## Solution\n\n::: { .solution exercise=\"count\"}\n\n\n\n\n::: {.cell exercise='count' solution='true'}\n```{webr}\n#| exercise: count\n#| solution: true\nincident_types <- count(df, incidentType)\n\nincident_types\n```\n:::\n\n::: {.cell exercise='count' check='true'}\n```{webr}\n#| exercise: count\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n::::\n\n\nOkay, great. The default new column is named \"n\".\n\nWe can change that by adding an extra argument to the `count()` function: `name=\"name_of_column\"`\n\nFill out the code below but call the new column you're creating \"total\".\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='count2'}\n```{webr}\n#| exercise: count2\nincident_types <- _____(df, _________, name=\"______\")\n\nincident_types\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"count2\"}\nYou're passing it a string so make sure the \ncolumn name is in between quotation marks\n:::\n\n## Solution\n\n::: { .solution exercise=\"count2\"}\n\n\n\n::: {.cell exercise='count2' solution='true'}\n```{webr}\n#| exercise: count2\n#| solution: true\nincident_types <- count(df, incidentType, name=\"total\")\n\nincident_types\n```\n:::\n\n::: {.cell exercise='count2' check='true'}\n```{webr}\n#| exercise: count2\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n\n::::\n\n## Arrange\n\nGreat! Now we're looking at table instead of a cluster of incident types.\n\nThis is much easier to scan.\n\nBut we're still dealing with alphabetically sorted incidents. \n\nWe need to look at which disaster types have occurred most often over time.\n\nWe're going to use a new function called `arrange()`\n\nWe have the new object data frame with the counts of incidents that you called **incident_types**.\n\nWe just need to use the `arrange()` function on the dataframe, specifically the new column you created called `total`.\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='arrange'}\n```{webr}\n#| exercise: arrange\nincident_types_arranged <- arrange(__________, _____)\n\nincident_types_arranged\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"arrange\"}\nIs your first argument in arrange() the name of the \nnewer dataframe you created using count()?\n  \nAlso, you don't need to put \"total\" in quotation marks this time!\nBecause column names aren't strings. They're objects.\n:::\n\n## Solution\n\n::: { .solution exercise=\"arrange}\n\n\n\n::: {.cell exercise='arrange' solution='true'}\n```{webr}\n#| exercise: arrange\n#| solution: true\nincident_types_arranged <- arrange(incident_types, total)\n\nincident_types_arranged\n```\n:::\n\n::: {.cell exercise='arrange' check='true'}\n```{webr}\n#| exercise: arrange\n#| check: true\ngrade_this_code()\n```\n:::\n\n\n\n\n:::\n\n::::\n\n### Arrange descending\n\nOkay, this isn't what we wanted. This is going in ascending order, aka, least to most.\n\nWe need most to least!\n\nSo we need to adjust the `arrange()` function with the `desc()` function wrapped around the column you're sorting on. \n\nYou're nesting functions.\n\nAdjust your code from before but use the `desc()` formula, too.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='arrange2'}\n```{webr}\n#| exercise: arrange2\nincident_types_arranged <- arrange(__________, ____(_____))\n\nincident_types_arranged\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"arrange2\"}\nIs your first argument in arrange() the name of the \nnewer dataframe you created using count()?\n  \nAlso, you don't need to put \"total\" in quotation marks this time!\nBecause column names aren't strings. They're objects.\n:::\n\n## Solution\n\n::: { .solution exercise=\"arrange2\"}\n\n\n\n\n::: {.cell exercise='arrange2' solution='true'}\n```{webr}\n#| exercise: arrange2\n#| solution: true\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nincident_types_arranged\n```\n:::\n\n::: {.cell exercise='arrange2' check='true'}\n```{webr}\n#| exercise: arrange2\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n\n::::\n\n\nGreat job!\n\nWe see that Severe Storms are the most-common disaster types declared.\n\nThen, hurricanes and floods.\n\n## Pipes\n\nPipes is `|>` which represents \"and then.\"\n\nIt allows you to daisy chain functions to transform data in a more readable format. It's very popular and more languages are implementing it. It works only if a function is structured in a way that the first argument is always the dataframe it's altering. For example:\n\n\n![](images/pipe.png)\n\nHere's the code that got you to this point:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n```\n:::\n\n\n\n\n## Without Pipes\n\n\n\n\n::: {.cell}\n```{webr}\ncounted <- count(df, state, name=\"disasters\")\nsorted_count <- arrange(counted, desc(disasters))\n\nsorted_count\n```\n:::\n\n\n\n\n## With Pipes\n\n\n\n\n::: {.cell}\n```{webr}\nsorted_pipes <- df |> \n  count(state, name=\"disasters\") |> \n  arrange(desc(disasters))\n\nsorted_pipes\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}