{
  "hash": "01136ef5d6171484d8782cad9c35026f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Mutating and summarizing data\nengine: knitr\nformat: live-html\nwebr:\n  packages:\n    - readr\n    - lubridate\n    - tidyr\n    - dplyr\n    - gradethis\n    - readxl\n    - janitor\n    - gradethis\nresources:\n  - images\n  - data\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n::: {.cell}\n```{webr}\n#| include: false\n\n#| \n\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nfloods <- df |> filter(incidentType==\"Flood\")\nfloods_adjusted <- floods |> \n  mutate(year=year(declarationDate))\nfloods_match <- floods_adjusted |> \n  mutate(year_match=\n           case_when(year==fyDeclared ~ \"Match\",\n                     TRUE ~ \"Not a match\"\n  )) |> \n  group_by(year_match) |> \n  summarize(total=n())\nfloods_match_count <- floods_match |> \n  filter(year_match==\"Not a match\") |> \n  pull(total)\n```\n:::\n\n::: {.cell edit='false' define='ok_reponse'}\n```{webr}\n#| edit: false\n#| output: false\n#| define:\n#|   - ok_reponse\nlibrary(htmltools)\nok_reponse <- function(reponse, n) {\n  if (is.na(reponse)) HTML(\"\")\n  else if (reponse == n) div(HTML(\"Correct ✓\"), style = \"color: green\")\n  else div(HTML(\"Incorrect ✗\"), style = \"color: red\")\n}\n```\n:::\n\n\n\n\n## Mutate\n\nAlright, so if you paginate to the right through the columns and look at `declarationDate`, you can see the data is VERY recent. \n\nOkay, let's see if we can do some analysis on this.\n\n**Have there been there more flood disaster declarations over time?**\n\nWe should extract the year from the `declarationDate` and count those up.\n\nTo create a new column in a data frame, you'll use the **dplyr** verb `mutate()`.\n\nYou just need to name the column you want to create and then pass it some function, formula, or object.\n\nWe're going to use the `year()` function from the **lubridate** package.\n\nThis extracts the year from a date type. Try it below.\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n\n::: {.cell exercise='mutate'}\n```{webr}\n#| exercise: mutate\nfloods_adjusted <- floods |> \n  ______(year=____(declarationDate))\n\nfloods_adjusted |> \n  select(year, declarationDate)\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"mutate\"}\nfunction starts with an *r*.\nAlso, in Base R, to focus on a single column in a data frame, \nyou need a dollar sign between the data frame name and column name\n:::\n\n## Solution\n\n::: { .solution exercise=\"mutate\"}\n\n\n\n::: {.cell exercise='mutate' solution='true'}\n```{webr}\n#| exercise: mutate\n#| solution: true\nfloods_adjusted <- floods |> \n  mutate(year=year(declarationDate)) \n\nfloods_adjusted |> \n  select(year, declarationDate)\n```\n:::\n\n::: {.cell exercise='mutate' check='true'}\n```{webr}\n#| exercise: mutate\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n:::\n::::\n\n\n## Summarize\n\nI've shown you how to count up rows within groups with `count()`.\n\nWhat if we wanted to go beyond counts? \n\nAnd maybe find the average deaths or median cost by type of disaster? \n\nOr we could drill down and find the average deaths by disaster broken out by state to see which one had the most?\n\nTo do that we'll need to use a couple of **dplyr** verbs: `group_by()` and `summarize()`.\n\nSummarizing data in R typically takes two steps: 1) Group the rows based on some value in the data, 2) Summarize those groups by counting the rows or doing math on values.\n\nThe Group and Summarize combo can be confusing. Here's a video from Christian McDonald that explains it [with candy](https://youtu.be/a3VNWYJoy5A).\n\nSo the `group_by()` and `summarize()` functions do the aggregation process in two steps. \n\nFirst we use `group_by()` to tell R which columns we want to group our data by - these are the higher level of aggregation columns so in our case will be the year of data. \n\nThen we need to determine the number of declarations each year. We do this using `summarize()`, and we’ll specify in the function that we want to do to the data. We're going to use the `n()` function which is just \"number of.\"\n\nHere's how it looks. Try using those two new functions below.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='summarize'}\n```{webr}\n#| exercise: summarize\nfloods |> \n  mutate(year=year(declarationDate)) |> \n  _______(year) |> \n  _________(total=n())\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"summarize\"}\nfunctions starts with an *g* and *s*.\n:::\n\n## Solution\n\n::: { .solution exercise=\"summarize\"}\n\n\n\n::: {.cell exercise='summarize' solution='true'}\n```{webr}\n#| exercise: summarize\n#| solution: true\nfloods |> \n  mutate(year=year(declarationDate)) |> \n  group_by(year) |> \n  summarize(total=n())\n```\n:::\n\n::: {.cell exercise='summarize' check='true'}\n```{webr}\n#| exercise: summarize\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n::::\n\nYou could also add more than one variable/column to `group_by()`. You could do `group_by(year, state)` for example...\n\n## case_when()\n\n### Why didn't we use fyDeclared?\n\nSome of you may be wondering why we created a new column **year** when we already had **fyDeclared** that had years as values.\n\nBecause that stands for Fiscal Year the disaster was declared.\n\nFiscal years are offset and end on September 30 because of budgetary reasons. \n\nSo any disasters that occur after September 30 are slotted in the next fiscal year. That's not accurate for what we're trying to measure.\n\nLet me show you how off our analysis would be if we used **fyDeclared** instead of creating a new column.\n\nWe're going to use a **dplyr** function called `case_when()` which is used within the `mutate()` function.\n\nIt's a powerful way to vectorize multiple if/else statements.\n\nWhat we want to do is create a new column called **year_match** that will indicate if the **year** column we created from **declarationDate** matches the value in the **fyDeclared** column.\n\nIf it matches, then mark it \"Match\" otherwise mark it as \"Not a match\".\n\nThe syntax is a [little tricky](https://twitter.com/allison_horst/status/1282785610273447936) but check it out below.\n\nFill in the new function name below:\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n::: {.cell exercise='case_when'}\n```{webr}\n#| exercise: case_when\nfloods_match <- floods_adjusted |> \n  mutate(year_match=\n           _________(year==fyDeclared ~ \"Match\",\n                     TRUE ~ \"Not a match\"\n  )) |> \n  group_by(year_match) |> \n  summarize(total=n())\n\nfloods_match\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"case_when\"}\nfunction starts with an *c*.\n:::\n\n## Solution\n\n::: { .solution exercise=\"case_when\"}\n\n\n\n\n::: {.cell exercise='case_when' solution='true'}\n```{webr}\n#| exercise: case_when\n#| solution: true\nfloods_match <- floods_adjusted |> \n  mutate(year_match=\n           case_when(year==fyDeclared ~ \"Match\",\n                     TRUE ~ \"Not a match\"\n  )) |> \n  group_by(year_match) |> \n  summarize(total=n())\n\nfloods_match\n```\n:::\n\n::: {.cell exercise='case_when' check='true'}\n```{webr}\n#| exercise: case_when\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n::::\n\nThe `TRUE ~ \"Not a match\"` is essentially, \"if none of the criteria fit from above, then fill the rest out as 'Not a match'\".\n\nSo there are more than 1,400 disasters that occurred on a fiscal year that didn't line up with the actual year.\n\n## Pull\n\n**What's the percent of that in the data?**\n\nYou could just pop the numbers you generated into a calculator and come up with the value but this data set is updated regularly so the number is going to change!\n\nLet's just script it out now so you can get the number really quickly in the future.\n\nIt's a time investment to set it up but it'll save you time in the long run.\n\nFirst, we need to take out the number for \"Not a match\"\n\nWe'll use a function called `pull()` that will isolate the values from whatever column you indicate.\n\nTry it below.\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='pull'}\n```{webr}\n#| exercise: pull\nfloods_match_count <- floods_match |> \n  filter(year_match==\"Not a match\") |> \n  ____(total)\n\nfloods_match_count\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"pull\"}\nfunction starts with an *p*.\n:::\n\n## Solution\n\n::: { .solution exercise=\"pull\"}\n\n\n\n::: {.cell exercise='pull' solution='true'}\n```{webr}\n#| exercise: pull\n#| solution: true\nfloods_match_count <- floods_match |> \n  filter(year_match==\"Not a match\") |> \n  pull(total)\n\nfloods_match_count\n```\n:::\n\n::: {.cell exercise='pull' check='true'}\n```{webr}\n#| exercise: pull\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n::::\n\nWe have that number isolated so let's use that with the `nrow()` function you learned earlier to get the denominator you need to establish the percent.\n\nWe'll also use a new function `round()` to get a prettier number that doesn't have so many trailing digits after the decimal.\n\nIt works like this: `round(4.12423212311, 1)` with the first argument being the number or numbers you're working with and the second argument is the digits after the decimal you want to keep. So the command above would give you 4.1.\n\nLet's script out our math:\n\n\n\n\n::: {.cell exercise='nrow2'}\n```{webr}\n#| exercise: nrow2\ntotal_obs <- nrow(floods)\n\nfloods_match_count / total_obs * 100\n\nround(floods_match_count / total_obs * 100,1)\n```\n:::\n\n\n\n\nAlright, we aren't going to use this for our story because it isn't significant or relevant to any story but it's for our own knowledge.\n\nThere's going to be so many calculations you come up with that won't end up in the story.\n\nIt's just like reporting. You gather as much research and talk to as many people as you can and then decide what's most important.\n\nBut you have to do the leg work to build up that sense of confidence in what you're writing.\n\n### What's the story?\n\nPut it all together from the beginning with pipes and verbs you've learned\n\nWhich year had the most floods declarations?\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='all_together'}\n```{webr}\n#| exercise: all_together\nannual_floods <- df |> \n  ______(incidentType==\"Flood\") |> \n  ______(year=year(declarationDate)) |> \n  ________(year) |> \n  _________(total=n()) |> \n  ________(desc(total))\n\nannual_floods\n```\n:::\n\n\n\n\n## Solution\n\n::: { .solution exercise=\"all_together\"}\n\n\n\n\n\n::: {.cell exercise='all_together' solution='true'}\n```{webr}\n#| exercise: all_together\n#| solution: true\nannual_floods <- df |> \n  filter(incidentType==\"Flood\") |> \n  mutate(year=year(declarationDate)) |> \n  group_by(year) |> \n  summarize(total=n()) |> \n  arrange(desc(total))\n\nannual_floods\n```\n:::\n\n::: {.cell exercise='all_together' check='true'}\n```{webr}\n#| exercise: all_together\n#| check: true\ngrade_this_code()\n```\n:::\n\n\n\n\n:::\n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}