{
  "hash": "1dc4b0ef53d552d5bd88e9395afc0ff5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Filter, Select\nengine: knitr\nformat: live-html\nwebr:\n  packages:\n    - readr\n    - lubridate\n    - tidyr\n    - dplyr\n    - gradethis\n    - readxl\n    - janitor\n    - DT\nresources:\n  - images\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n::: {.cell}\n```{webr}\n#| include: false\n#| \n\n\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nfloods <- df |> filter(incidentType==\"Flood\")\nfloods_adjusted <- floods |> \n  mutate(year=year(declarationDate))\nfloods_match <- floods_adjusted |> \n  mutate(year_match=\n           case_when(year==fyDeclared ~ \"Match\",\n                     TRUE ~ \"Not a match\"\n  )) |> \n  group_by(year_match) |> \n  summarize(total=n())\nfloods_match_count <- floods_match |> \n  filter(year_match==\"Not a match\") |> \n  pull(total)\n\nrev_chron_floods <- floods |> \n  arrange(desc(declarationDate)) |> \n  slice(1:5)\n\n```\n:::\n\n\n\n\n## Filter\n\nLet's take a look at our data frame **incident_types_arranged** again.\n\n\n\n\n::: {.cell}\n```{webr}\nincident_types_arranged\n```\n:::\n\n\n\n\nOne disaster of note after the three biggest ones is \"Biological\"-- but I'm going to tell you now to exclude that because those are all related to Covid-19. So consider those outliers to be excluded from your analysis.\n\nLet's do that now with the `filter()` function from **dplyr**.\n\nYou can filter based on values in a column/vector with these logical operators:\n\n\n| Operator          | Definition               |\n|:------------------:|:-------------------------:|\n| x `<` y         | Less than                |\n| x `>` y         | Greater than             |\n| x `==` y        | Equal to                 |\n| x `<=` y        | Less than or equal to    |\n| x `>=` y        | Greater than or equal to |\n| x `!=` y        | Not equal to             |\n| x `%in%` c(y,z) | In a group               |\n| `is.na(`x`)`  | Is NA                    |\n| `!is.na(`x`)` | Is not NA                |\n\n\nEqual signs can be confusing\n\n* `==` tests whether the objects on either end are equal. This is often used in filtering data\n* `=` makes an object equal to a value, which is similar to <- but used within a function (can't be used in a filter).\n\nGo ahead and take the data frame **incident_types_arranged** and filter out **Biological** from the `incidentType` column.\n\nUse the `!=` operator which means \"not equal to.\"\n\nAssign the new datframe to a new object called **incident_types_arranged_filtered**.\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='filter'}\n```{webr}\n#| exercise: filter\nincident_types_arranged_filtered <- incident_types_arranged |> \n  filter(_______ != _________)\n\nincident_types_arranged_filtered \n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"filter\"}\nMake sure what you're filtering for, if a string, is in quotation marks.\nOtherwise, R will think you're looking for some object that might represent something else.\n:::\n\n## Solution\n\n::: { .solution exercise=\"filter\"}\n\n\n\n\n::: {.cell exercise='filter' solution='true'}\n```{webr}\n#| exercise: filter\n#| solution: true\nincident_types_arranged_filtered <- incident_types_arranged |> \n  filter(incidentType != \"Biological\")\n\nincident_types_arranged_filtered \n```\n:::\n\n::: {.cell exercise='filter' check='true'}\n```{webr}\n#| exercise: filter\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n\n::::\n\n### Filter multiple values\n\nAlright, this one's an amazing filtering tool and you should know about it now.\n\nWhat if you want to filter multiple items? Well, you'd have to use Boolean logic operators such as:\n\n* `&` means AND, in Boolean logic\n* `|` means OR, in Boolean logic\n* `!` means NOT, in Boolean logic\n\nLet's look for the Tornado and Hurricane and incidents only. \n\nSince we're looking for either of those, we have to use the OR logic, or the `|` operator.\n\nThis code below needs fixing before it can run successfully.\n\nTry running it and deciphering the error message to fix the code.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='multiple_filter1'}\n```{webr}\n#| exercise: multiple_filter1\nincident_types_arranged |> \n  filter(incidentType==\"Tornado\" | incidentType = \"Hurricane\") \n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"multiple_filter1\"}\nIs it using the right operators?\n:::\n\n## Solution\n\n::: { .solution exercise=\"multiple_filter1\"}\n\n\n\n\n::: {.cell exercise='multiple_filter1' solution='true'}\n```{webr}\n#| exercise: multiple_filter1\n#| solution: true\nincident_types_arranged |> \n  filter(incidentType==\"Tornado\" | incidentType == \"Hurricane\") \n```\n:::\n\n::: {.cell exercise='multiple_filter1' check='true'}\n```{webr}\n#| exercise: multiple_filter1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n:::\n\n::::\n\n### %in%\n\nMakes sense?\n\nNow this can get unwieldy if you have a lot of different types to filter by.\n\nThat's why you should create an array of the categories you want to filter by and then use the powerful `%in%` operator.\n\nLet's look for Tornadoes, Hurricanes, and Floods. We'll use the `c()` function (as in combine) to create an array of that list.\n\nPlug in the new operator and the object name in the code below.\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='multiple_filter2'}\n```{webr}\n#| exercise: multiple_filter2\ndisaster_array <- c(\"Tornado\", \"Hurricane\", \"Flood\")\n\nincident_types_arranged |> \n  filter(incidentType ___ ______________) \n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"multiple_filter2\"}\n\nObjects don't need to be in quotation marks.\n\n:::\n\n## Solution\n\n::: { .solution exercise=\"multiple_filter2\"}\n\n\n\n\n::: {.cell exercise='multiple_filter2' solution='true'}\n```{webr}\n#| exercise: multiple_filter2\n#| solution: true\ndisaster_array <- c(\"Tornado\", \"Hurricane\", \"Flood\")\n\nincident_types_arranged |> \n  filter(incidentType %in% disaster_array) \n```\n:::\n\n::: {.cell exercise='multiple_filter2' check='true'}\n```{webr}\n#| exercise: multiple_filter2\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n::::\n\n## Missing values\n\nSometimes your data will have missing values, which will trip up R when making calculations.\n\nTry running the code below and see the differences.\n\n\n\n\n::: {.cell exercise='missing_na'}\n```{webr}\n#| exercise: missing_na\n10+0\n\n10+NA\n```\n:::\n\n\n\n\nAdding `NA` to anything will make the entire result `NA` which isn't great. Later, we'll talk about strategies on getting around it. \nBut for now let's just see if there are any in the columns we're interested.\n\nIt's also good to know if your data can actually be usable or if it's trash.\n\nThe quickest way to check for `NA` values is with the `is.na()` function from Base R. You'll need to run it on a specific column (remember `$`?).\n\n**Note: ** `NA` is different from zeroes, which means the value is actually zero. A zero is not the same as \"no value\". \n\nUncomment and run the first line of code below and then add the comment back and uncomment the other one and run that one.\n\n**Note:** Uncomment means delete the `#` in front of the line of code.\n\n\n\n\n::: {.cell exercise='missing'}\n```{webr}\n#| exercise: missing\n#is.na(df$incidentType)\n#sum(is.na(df$incidentType))\n```\n:::\n\n\n\n\n**Which one is better?**\n\n\n\n```{ojs}\n//| echo: false\nmutable ok_reponse = (reponse, n) => { return html`Loading...` };\nviewof reponse = Inputs.radio(\n  new Map([\n    [\"sum(is.na(df$incidentType)) because the output is a single number\", 1],\n    [\"is.na(df$incidentType) because I want to see if every single row in the data frame has an NA value or not\", 2]\n  ])\n);\nok_reponse(reponse, 1);\n```\n\n\n\n\n\n\nAlright, so this question is pretty subjective. There are times when you'll want to see which row in the data frame has an `NA`. \n\nBut for now, let's just focus on the number: 0. That's good!\n\nNow, we can proceed with some sense of security.\n\n## Select\n\nThe Base R function `nrow()` will tell you how many rows there are in a dataframe.\n\n\n\n\n::: {.cell exercise='nrow'}\n```{webr}\n#| exercise: nrow\nnrow(df)\n```\n:::\n\n\n\n\nAnd `colnames()` will tell you what the column names are.\n\n\n\n\n::: {.cell exercise='colnames'}\n```{webr}\n#| exercise: colnames\ncolnames(df)\n```\n:::\n\n\n\n\nThis is relevant because sometimes you'll want to create a data frame with a limited amount of columns.\n\nMaybe because it's easier to read and scroll through or it'll free up memory on your computer.\n\nThe **dplyr** verb you'll need to use is `select()`\n\nYou simply insert the column names you want. And you won't need to put the column names in quotes (unless there's a space in the column name).\n\nTry it below with the correct function name.\n\n\n::: {.panel-tabset}\n\n## Exercise\n\n\n\n::: {.cell exercise='select'}\n```{webr}\n#| exercise: select\ndf_narrow <- df |> \n  ______(femaDeclarationString, state, declarationDate, \n         fyDeclared, designatedArea, incidentType)\n\ncolnames(df_narrow)\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"select\"}\nWhat's the verb?\n:::\n\n## Solution\n\n::: { .solution exercise=\"select\"}\n\n\n\n\n::: {.cell exercise='select' solution='true'}\n```{webr}\n#| exercise: select\n#| solution: true\ndf_narrow <- df |> \n  select(femaDeclarationString, state, declarationDate, \n         fyDeclared, designatedArea, incidentType)\n\ncolnames(df_narrow)\n```\n:::\n\n::: {.cell exercise='select' check='true'}\n```{webr}\n#| exercise: select\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n:::\n\n::::\n\n## Slice\n\nOkay, for the rest of today's class let's see if we can look for a story from the data.\n\nRecently, there's been a pretty devastating flood in North Carolina, so let's focus on that topic.\n\nCan you write the code to look only at floods from mostly scratch? What the function is called and what operator you need to use and the proper syntax for the keyword you're isolating the data frame to?  \n\nStart with the original `df` object and pipe.\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='floods'}\n```{webr}\n#| exercise: floods\nfloods <- df |> \n  __________________________\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"floods\"}\nWhat's the verb/function that filters to flood?\n\nWhat is it you're filtering for and what column are you looking in?\n  \nQuotation marks? Case sensitivity?\n:::\n\n## Solution\n\n::: { .solution exercise=\"floods\"}\n\n\n\n::: {.cell exercise='floods' solution='true'}\n```{webr}\n#| exercise: floods\n#| solution: true\nfloods <- df |> \n  filter(incidentType==\"Flood\")\n```\n:::\n\n::: {.cell exercise='floods' check='true'}\n```{webr}\n#| exercise: floods\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n:::\n::::\n\nLet's take a look at the five most-recent flooding declared disasters with a new function, `slice()`\n\nIf you give it a number, it will slice out that specific row in the data.\n\nIf you give it a range, like `1:10` it will slice out rows 1 through 10.\n\nGive it a try below. Get rows 1 through 5.\n\n::: { .panel-tabset}\n\n## Exercise\n\n\n\n\n::: {.cell exercise='slice'}\n```{webr}\n#| exercise: slice\nrev_chron_floods <- floods |> \n  arrange(desc(declarationDate)) |> \n  _____(___)\n\nrev_chron_floods\n```\n:::\n\n\n\n\n## Hint\n\n::: { .hint exercise=\"slice\"}\nfunction starts with an *s*.\nDon't forget the \":\"\n:::\n\n## Solution\n\n::: { .solution exercise=\"slice\"}\n\n\n\n::: {.cell exercise='slice' solution='true'}\n```{webr}\n#| exercise: slice\n#| solution: true\nrev_chron_floods <- floods |> \n  arrange(desc(declarationDate)) |> \n  slice(1:5)\n\nrev_chron_floods\n```\n:::\n\n::: {.cell exercise='slice' check='true'}\n```{webr}\n#| exercise: slice\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n\n\n\n:::\n::::\n\n## Pretty table\n\nThe output above isn't that nice or searchable. Use the `datatable()` function from the `DT` package.\n\n\n\n\n::: {.cell}\n```{webr}\nlibrary(DT)\n\ndatatable(rev_chron_floods)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}