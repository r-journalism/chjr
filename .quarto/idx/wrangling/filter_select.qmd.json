{"title":"Filter, Select","markdown":{"yaml":{"title":"Filter, Select","engine":"knitr","format":"live-html","webr":{"packages":["readr","lubridate","tidyr","dplyr","gradethis","readxl","janitor","DT"]},"resources":["images"]},"headingText":"Filter","containsRefs":false,"markdown":"\n\n{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}\n{{< include ../_extensions/r-wasm/live/_gradethis.qmd >}}\n\n\n```{webr 2}\n#| include: false\n#| \n\n\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nfloods <- df |> filter(incidentType==\"Flood\")\nfloods_adjusted <- floods |> \n  mutate(year=year(declarationDate))\nfloods_match <- floods_adjusted |> \n  mutate(year_match=\n           case_when(year==fyDeclared ~ \"Match\",\n                     TRUE ~ \"Not a match\"\n  )) |> \n  group_by(year_match) |> \n  summarize(total=n())\nfloods_match_count <- floods_match |> \n  filter(year_match==\"Not a match\") |> \n  pull(total)\n\nrev_chron_floods <- floods |> \n  arrange(desc(declarationDate)) |> \n  slice(1:5)\n\n```\n\n\nLet's take a look at our data frame **incident_types_arranged** again.\n\n```{webr df_view}\nincident_types_arranged\n```\n\nOne disaster of note after the three biggest ones is \"Biological\"-- but I'm going to tell you now to exclude that because those are all related to Covid-19. So consider those outliers to be excluded from your analysis.\n\nLet's do that now with the `filter()` function from **dplyr**.\n\nYou can filter based on values in a column/vector with these logical operators:\n\n\n| Operator          | Definition               |\n|:------------------:|:-------------------------:|\n| x `<` y         | Less than                |\n| x `>` y         | Greater than             |\n| x `==` y        | Equal to                 |\n| x `<=` y        | Less than or equal to    |\n| x `>=` y        | Greater than or equal to |\n| x `!=` y        | Not equal to             |\n| x `%in%` c(y,z) | In a group               |\n| `is.na(`x`)`  | Is NA                    |\n| `!is.na(`x`)` | Is not NA                |\n\n\nEqual signs can be confusing\n\n* `==` tests whether the objects on either end are equal. This is often used in filtering data\n* `=` makes an object equal to a value, which is similar to <- but used within a function (can't be used in a filter).\n\nGo ahead and take the data frame **incident_types_arranged** and filter out **Biological** from the `incidentType` column.\n\nUse the `!=` operator which means \"not equal to.\"\n\nAssign the new datframe to a new object called **incident_types_arranged_filtered**.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr filter}\n#| exercise: filter\nincident_types_arranged_filtered <- incident_types_arranged |> \n  filter(_______ != _________)\n\nincident_types_arranged_filtered \n```\n\n## Hint\n\n::: { .hint exercise=\"filter\"}\nMake sure what you're filtering for, if a string, is in quotation marks.\nOtherwise, R will think you're looking for some object that might represent something else.\n:::\n\n## Solution\n\n::: { .solution exercise=\"filter\"}\n\n```{webr filter-solution}\n#| exercise: filter\n#| solution: true\nincident_types_arranged_filtered <- incident_types_arranged |> \n  filter(incidentType != \"Biological\")\n\nincident_types_arranged_filtered \n```\n\n\n```{webr filter-check}\n#| exercise: filter\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n\n::::\n\n### Filter multiple values\n\nAlright, this one's an amazing filtering tool and you should know about it now.\n\nWhat if you want to filter multiple items? Well, you'd have to use Boolean logic operators such as:\n\n* `&` means AND, in Boolean logic\n* `|` means OR, in Boolean logic\n* `!` means NOT, in Boolean logic\n\nLet's look for the Tornado and Hurricane and incidents only. \n\nSince we're looking for either of those, we have to use the OR logic, or the `|` operator.\n\nThis code below needs fixing before it can run successfully.\n\nTry running it and deciphering the error message to fix the code.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr multiple_filter1}\n#| exercise: multiple_filter1\nincident_types_arranged |> \n  filter(incidentType==\"Tornado\" | incidentType = \"Hurricane\") \n```\n\n## Hint\n\n::: { .hint exercise=\"multiple_filter1\"}\nIs it using the right operators?\n:::\n\n## Solution\n\n::: { .solution exercise=\"multiple_filter1\"}\n\n```{webr multiple_filter1-solution}\n#| exercise: multiple_filter1\n#| solution: true\nincident_types_arranged |> \n  filter(incidentType==\"Tornado\" | incidentType == \"Hurricane\") \n```\n\n\n```{webr multiple_filter1-check}\n#| exercise: multiple_filter1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n::::\n\n### %in%\n\nMakes sense?\n\nNow this can get unwieldy if you have a lot of different types to filter by.\n\nThat's why you should create an array of the categories you want to filter by and then use the powerful `%in%` operator.\n\nLet's look for Tornadoes, Hurricanes, and Floods. We'll use the `c()` function (as in combine) to create an array of that list.\n\nPlug in the new operator and the object name in the code below.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr multiple_filter2}\n#| exercise: multiple_filter2\ndisaster_array <- c(\"Tornado\", \"Hurricane\", \"Flood\")\n\nincident_types_arranged |> \n  filter(incidentType ___ ______________) \n```\n\n## Hint\n\n::: { .hint exercise=\"multiple_filter2\"}\n\nObjects don't need to be in quotation marks.\n\n:::\n\n## Solution\n\n::: { .solution exercise=\"multiple_filter2\"}\n\n```{webr multiple_filter2-solution}\n#| exercise: multiple_filter2\n#| solution: true\ndisaster_array <- c(\"Tornado\", \"Hurricane\", \"Flood\")\n\nincident_types_arranged |> \n  filter(incidentType %in% disaster_array) \n```\n\n\n```{webr multiple_filter2-check}\n#| exercise: multiple_filter2\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n::::\n\n## Missing values\n\nSometimes your data will have missing values, which will trip up R when making calculations.\n\nTry running the code below and see the differences.\n\n```{webr missing_na}\n#| exercise: missing_na\n10+0\n\n10+NA\n```\n\nAdding `NA` to anything will make the entire result `NA` which isn't great. Later, we'll talk about strategies on getting around it. \nBut for now let's just see if there are any in the columns we're interested.\n\nIt's also good to know if your data can actually be usable or if it's trash.\n\nThe quickest way to check for `NA` values is with the `is.na()` function from Base R. You'll need to run it on a specific column (remember `$`?).\n\n**Note: ** `NA` is different from zeroes, which means the value is actually zero. A zero is not the same as \"no value\". \n\nUncomment and run the first line of code below and then add the comment back and uncomment the other one and run that one.\n\n**Note:** Uncomment means delete the `#` in front of the line of code.\n\n```{webr missing}\n#| exercise: missing\n#is.na(df$incidentType)\n#sum(is.na(df$incidentType))\n```\n\n**Which one is better?**\n```{ojs}\n//| echo: false\nmutable ok_reponse = (reponse, n) => { return html`Loading...` };\nviewof reponse = Inputs.radio(\n  new Map([\n    [\"sum(is.na(df$incidentType)) because the output is a single number\", 1],\n    [\"is.na(df$incidentType) because I want to see if every single row in the data frame has an NA value or not\", 2]\n  ])\n);\nok_reponse(reponse, 1);\n```\n\n\n\nAlright, so this question is pretty subjective. There are times when you'll want to see which row in the data frame has an `NA`. \n\nBut for now, let's just focus on the number: 0. That's good!\n\nNow, we can proceed with some sense of security.\n\n## Select\n\nThe Base R function `nrow()` will tell you how many rows there are in a dataframe.\n\n```{webr nrow}\n#| exercise: nrow\nnrow(df)\n```\n\nAnd `colnames()` will tell you what the column names are.\n\n```{webr colnames}\n#| exercise: colnames\ncolnames(df)\n```\n\nThis is relevant because sometimes you'll want to create a data frame with a limited amount of columns.\n\nMaybe because it's easier to read and scroll through or it'll free up memory on your computer.\n\nThe **dplyr** verb you'll need to use is `select()`\n\nYou simply insert the column names you want. And you won't need to put the column names in quotes (unless there's a space in the column name).\n\nTry it below with the correct function name.\n\n\n::: {.panel-tabset}\n\n## Exercise\n```{webr select}\n#| exercise: select\ndf_narrow <- df |> \n  ______(femaDeclarationString, state, declarationDate, \n         fyDeclared, designatedArea, incidentType)\n\ncolnames(df_narrow)\n```\n\n## Hint\n\n::: { .hint exercise=\"select\"}\nWhat's the verb?\n:::\n\n## Solution\n\n::: { .solution exercise=\"select\"}\n\n```{webr select-solution}\n#| exercise: select\n#| solution: true\ndf_narrow <- df |> \n  select(femaDeclarationString, state, declarationDate, \n         fyDeclared, designatedArea, incidentType)\n\ncolnames(df_narrow)\n```\n\n```{webr select-check}\n#| exercise: select\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n\n::::\n\n## Slice\n\nOkay, for the rest of today's class let's see if we can look for a story from the data.\n\nRecently, there's been a pretty devastating flood in North Carolina, so let's focus on that topic.\n\nCan you write the code to look only at floods from mostly scratch? What the function is called and what operator you need to use and the proper syntax for the keyword you're isolating the data frame to?  \n\nStart with the original `df` object and pipe.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr floods}\n#| exercise: floods\nfloods <- df |> \n  __________________________\n```\n\n## Hint\n\n::: { .hint exercise=\"floods\"}\nWhat's the verb/function that filters to flood?\n\nWhat is it you're filtering for and what column are you looking in?\n  \nQuotation marks? Case sensitivity?\n:::\n\n## Solution\n\n::: { .solution exercise=\"floods\"}\n```{webr floods-solution}\n#| exercise: floods\n#| solution: true\nfloods <- df |> \n  filter(incidentType==\"Flood\")\n```\n\n\n```{webr floods-check}\n#| exercise: floods\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n::::\n\nLet's take a look at the five most-recent flooding declared disasters with a new function, `slice()`\n\nIf you give it a number, it will slice out that specific row in the data.\n\nIf you give it a range, like `1:10` it will slice out rows 1 through 10.\n\nGive it a try below. Get rows 1 through 5.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr slice}\n#| exercise: slice\nrev_chron_floods <- floods |> \n  arrange(desc(declarationDate)) |> \n  _____(___)\n\nrev_chron_floods\n```\n\n## Hint\n\n::: { .hint exercise=\"slice\"}\nfunction starts with an *s*.\nDon't forget the \":\"\n:::\n\n## Solution\n\n::: { .solution exercise=\"slice\"}\n```{webr slice-solution}\n#| exercise: slice\n#| solution: true\nrev_chron_floods <- floods |> \n  arrange(desc(declarationDate)) |> \n  slice(1:5)\n\nrev_chron_floods\n```\n\n\n```{webr slice-check}\n#| exercise: slice\n#| check: true\ngradethis::grade_this_code()\n```\n\n\n:::\n::::\n\n## Pretty table\n\nThe output above isn't that nice or searchable. Use the `datatable()` function from the `DT` package.\n\n```{webr}\nlibrary(DT)\n\ndatatable(rev_chron_floods)\n```\n","srcMarkdownNoYaml":"\n\n{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}\n{{< include ../_extensions/r-wasm/live/_gradethis.qmd >}}\n\n\n```{webr 2}\n#| include: false\n#| \n\n\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nfloods <- df |> filter(incidentType==\"Flood\")\nfloods_adjusted <- floods |> \n  mutate(year=year(declarationDate))\nfloods_match <- floods_adjusted |> \n  mutate(year_match=\n           case_when(year==fyDeclared ~ \"Match\",\n                     TRUE ~ \"Not a match\"\n  )) |> \n  group_by(year_match) |> \n  summarize(total=n())\nfloods_match_count <- floods_match |> \n  filter(year_match==\"Not a match\") |> \n  pull(total)\n\nrev_chron_floods <- floods |> \n  arrange(desc(declarationDate)) |> \n  slice(1:5)\n\n```\n\n## Filter\n\nLet's take a look at our data frame **incident_types_arranged** again.\n\n```{webr df_view}\nincident_types_arranged\n```\n\nOne disaster of note after the three biggest ones is \"Biological\"-- but I'm going to tell you now to exclude that because those are all related to Covid-19. So consider those outliers to be excluded from your analysis.\n\nLet's do that now with the `filter()` function from **dplyr**.\n\nYou can filter based on values in a column/vector with these logical operators:\n\n\n| Operator          | Definition               |\n|:------------------:|:-------------------------:|\n| x `<` y         | Less than                |\n| x `>` y         | Greater than             |\n| x `==` y        | Equal to                 |\n| x `<=` y        | Less than or equal to    |\n| x `>=` y        | Greater than or equal to |\n| x `!=` y        | Not equal to             |\n| x `%in%` c(y,z) | In a group               |\n| `is.na(`x`)`  | Is NA                    |\n| `!is.na(`x`)` | Is not NA                |\n\n\nEqual signs can be confusing\n\n* `==` tests whether the objects on either end are equal. This is often used in filtering data\n* `=` makes an object equal to a value, which is similar to <- but used within a function (can't be used in a filter).\n\nGo ahead and take the data frame **incident_types_arranged** and filter out **Biological** from the `incidentType` column.\n\nUse the `!=` operator which means \"not equal to.\"\n\nAssign the new datframe to a new object called **incident_types_arranged_filtered**.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr filter}\n#| exercise: filter\nincident_types_arranged_filtered <- incident_types_arranged |> \n  filter(_______ != _________)\n\nincident_types_arranged_filtered \n```\n\n## Hint\n\n::: { .hint exercise=\"filter\"}\nMake sure what you're filtering for, if a string, is in quotation marks.\nOtherwise, R will think you're looking for some object that might represent something else.\n:::\n\n## Solution\n\n::: { .solution exercise=\"filter\"}\n\n```{webr filter-solution}\n#| exercise: filter\n#| solution: true\nincident_types_arranged_filtered <- incident_types_arranged |> \n  filter(incidentType != \"Biological\")\n\nincident_types_arranged_filtered \n```\n\n\n```{webr filter-check}\n#| exercise: filter\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n\n::::\n\n### Filter multiple values\n\nAlright, this one's an amazing filtering tool and you should know about it now.\n\nWhat if you want to filter multiple items? Well, you'd have to use Boolean logic operators such as:\n\n* `&` means AND, in Boolean logic\n* `|` means OR, in Boolean logic\n* `!` means NOT, in Boolean logic\n\nLet's look for the Tornado and Hurricane and incidents only. \n\nSince we're looking for either of those, we have to use the OR logic, or the `|` operator.\n\nThis code below needs fixing before it can run successfully.\n\nTry running it and deciphering the error message to fix the code.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr multiple_filter1}\n#| exercise: multiple_filter1\nincident_types_arranged |> \n  filter(incidentType==\"Tornado\" | incidentType = \"Hurricane\") \n```\n\n## Hint\n\n::: { .hint exercise=\"multiple_filter1\"}\nIs it using the right operators?\n:::\n\n## Solution\n\n::: { .solution exercise=\"multiple_filter1\"}\n\n```{webr multiple_filter1-solution}\n#| exercise: multiple_filter1\n#| solution: true\nincident_types_arranged |> \n  filter(incidentType==\"Tornado\" | incidentType == \"Hurricane\") \n```\n\n\n```{webr multiple_filter1-check}\n#| exercise: multiple_filter1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n::::\n\n### %in%\n\nMakes sense?\n\nNow this can get unwieldy if you have a lot of different types to filter by.\n\nThat's why you should create an array of the categories you want to filter by and then use the powerful `%in%` operator.\n\nLet's look for Tornadoes, Hurricanes, and Floods. We'll use the `c()` function (as in combine) to create an array of that list.\n\nPlug in the new operator and the object name in the code below.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr multiple_filter2}\n#| exercise: multiple_filter2\ndisaster_array <- c(\"Tornado\", \"Hurricane\", \"Flood\")\n\nincident_types_arranged |> \n  filter(incidentType ___ ______________) \n```\n\n## Hint\n\n::: { .hint exercise=\"multiple_filter2\"}\n\nObjects don't need to be in quotation marks.\n\n:::\n\n## Solution\n\n::: { .solution exercise=\"multiple_filter2\"}\n\n```{webr multiple_filter2-solution}\n#| exercise: multiple_filter2\n#| solution: true\ndisaster_array <- c(\"Tornado\", \"Hurricane\", \"Flood\")\n\nincident_types_arranged |> \n  filter(incidentType %in% disaster_array) \n```\n\n\n```{webr multiple_filter2-check}\n#| exercise: multiple_filter2\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n::::\n\n## Missing values\n\nSometimes your data will have missing values, which will trip up R when making calculations.\n\nTry running the code below and see the differences.\n\n```{webr missing_na}\n#| exercise: missing_na\n10+0\n\n10+NA\n```\n\nAdding `NA` to anything will make the entire result `NA` which isn't great. Later, we'll talk about strategies on getting around it. \nBut for now let's just see if there are any in the columns we're interested.\n\nIt's also good to know if your data can actually be usable or if it's trash.\n\nThe quickest way to check for `NA` values is with the `is.na()` function from Base R. You'll need to run it on a specific column (remember `$`?).\n\n**Note: ** `NA` is different from zeroes, which means the value is actually zero. A zero is not the same as \"no value\". \n\nUncomment and run the first line of code below and then add the comment back and uncomment the other one and run that one.\n\n**Note:** Uncomment means delete the `#` in front of the line of code.\n\n```{webr missing}\n#| exercise: missing\n#is.na(df$incidentType)\n#sum(is.na(df$incidentType))\n```\n\n**Which one is better?**\n```{ojs}\n//| echo: false\nmutable ok_reponse = (reponse, n) => { return html`Loading...` };\nviewof reponse = Inputs.radio(\n  new Map([\n    [\"sum(is.na(df$incidentType)) because the output is a single number\", 1],\n    [\"is.na(df$incidentType) because I want to see if every single row in the data frame has an NA value or not\", 2]\n  ])\n);\nok_reponse(reponse, 1);\n```\n\n\n\nAlright, so this question is pretty subjective. There are times when you'll want to see which row in the data frame has an `NA`. \n\nBut for now, let's just focus on the number: 0. That's good!\n\nNow, we can proceed with some sense of security.\n\n## Select\n\nThe Base R function `nrow()` will tell you how many rows there are in a dataframe.\n\n```{webr nrow}\n#| exercise: nrow\nnrow(df)\n```\n\nAnd `colnames()` will tell you what the column names are.\n\n```{webr colnames}\n#| exercise: colnames\ncolnames(df)\n```\n\nThis is relevant because sometimes you'll want to create a data frame with a limited amount of columns.\n\nMaybe because it's easier to read and scroll through or it'll free up memory on your computer.\n\nThe **dplyr** verb you'll need to use is `select()`\n\nYou simply insert the column names you want. And you won't need to put the column names in quotes (unless there's a space in the column name).\n\nTry it below with the correct function name.\n\n\n::: {.panel-tabset}\n\n## Exercise\n```{webr select}\n#| exercise: select\ndf_narrow <- df |> \n  ______(femaDeclarationString, state, declarationDate, \n         fyDeclared, designatedArea, incidentType)\n\ncolnames(df_narrow)\n```\n\n## Hint\n\n::: { .hint exercise=\"select\"}\nWhat's the verb?\n:::\n\n## Solution\n\n::: { .solution exercise=\"select\"}\n\n```{webr select-solution}\n#| exercise: select\n#| solution: true\ndf_narrow <- df |> \n  select(femaDeclarationString, state, declarationDate, \n         fyDeclared, designatedArea, incidentType)\n\ncolnames(df_narrow)\n```\n\n```{webr select-check}\n#| exercise: select\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n\n::::\n\n## Slice\n\nOkay, for the rest of today's class let's see if we can look for a story from the data.\n\nRecently, there's been a pretty devastating flood in North Carolina, so let's focus on that topic.\n\nCan you write the code to look only at floods from mostly scratch? What the function is called and what operator you need to use and the proper syntax for the keyword you're isolating the data frame to?  \n\nStart with the original `df` object and pipe.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr floods}\n#| exercise: floods\nfloods <- df |> \n  __________________________\n```\n\n## Hint\n\n::: { .hint exercise=\"floods\"}\nWhat's the verb/function that filters to flood?\n\nWhat is it you're filtering for and what column are you looking in?\n  \nQuotation marks? Case sensitivity?\n:::\n\n## Solution\n\n::: { .solution exercise=\"floods\"}\n```{webr floods-solution}\n#| exercise: floods\n#| solution: true\nfloods <- df |> \n  filter(incidentType==\"Flood\")\n```\n\n\n```{webr floods-check}\n#| exercise: floods\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n::::\n\nLet's take a look at the five most-recent flooding declared disasters with a new function, `slice()`\n\nIf you give it a number, it will slice out that specific row in the data.\n\nIf you give it a range, like `1:10` it will slice out rows 1 through 10.\n\nGive it a try below. Get rows 1 through 5.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr slice}\n#| exercise: slice\nrev_chron_floods <- floods |> \n  arrange(desc(declarationDate)) |> \n  _____(___)\n\nrev_chron_floods\n```\n\n## Hint\n\n::: { .hint exercise=\"slice\"}\nfunction starts with an *s*.\nDon't forget the \":\"\n:::\n\n## Solution\n\n::: { .solution exercise=\"slice\"}\n```{webr slice-solution}\n#| exercise: slice\n#| solution: true\nrev_chron_floods <- floods |> \n  arrange(desc(declarationDate)) |> \n  slice(1:5)\n\nrev_chron_floods\n```\n\n\n```{webr slice-check}\n#| exercise: slice\n#| check: true\ngradethis::grade_this_code()\n```\n\n\n:::\n::::\n\n## Pretty table\n\nThe output above isn't that nice or searchable. Use the `datatable()` function from the `DT` package.\n\n```{webr}\nlibrary(DT)\n\ndatatable(rev_chron_floods)\n```\n"},"formats":{"live-html":{"identifier":{"display-name":"HTML","target-format":"live-html","base-format":"html","extension-name":"live"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["/Users/andrewtran/Projects/chjr/_extensions/r-wasm/live/live.lua"],"output-file":"filter_select.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","ojs-engine":true,"revealjs-plugins":[],"theme":{"light":"cosmo","dark":"darkly"},"title":"Filter, Select","webr":{"packages":["readr","lubridate","tidyr","dplyr","gradethis","readxl","janitor","DT"]},"resources":["images"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}