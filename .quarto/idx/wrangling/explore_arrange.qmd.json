{"title":"Exploring, arrange, count","markdown":{"yaml":{"title":"Exploring, arrange, count","engine":"knitr","format":"live-html","webr":{"packages":["readr","dplyr","lubridate","gradethis"]},"resources":["images"]},"headingText":"Intro","containsRefs":false,"markdown":"\n\n\n{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}\n{{< include ../_extensions/r-wasm/live/_gradethis.qmd >}}\n\n\n```{webr}\n#| include: false\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nfloods <- df |> filter(incidentType==\"Flood\")\nfloods_adjusted <- floods |> \n  mutate(year=year(declarationDate))\nfloods_match <- floods_adjusted |> \n  mutate(year_match=\n           case_when(year==fyDeclared ~ \"Match\",\n                     TRUE ~ \"Not a match\"\n  )) |> \n  group_by(year_match) |> \n  summarize(total=n())\nfloods_match_count <- floods_match |> \n  filter(year_match==\"Not a match\") |> \n  pull(total)\n```\n\n\n```{webr 3}\n#| edit: false\n#| output: false\n#| define:\n#|   - ok_reponse\nlibrary(htmltools)\nok_reponse <- function(reponse, n) {\n  if (is.na(reponse)) HTML(\"\")\n  else if (reponse == n) div(HTML(\"Correct ✓\"), style = \"color: green\")\n  else div(HTML(\"Incorrect ✗\"), style = \"color: red\")\n}\n```\n\n\n\nIn this lesson, we're going to start exploring data with the package **dplyr.**\n\n* It's designed to work with data frames, which is what journalists are used to\n* Great for data exploration and transformation\n* Intuitive to write and easy to read, especially when using the “chaining” syntax of pipes\n\nThese are the functions/data analysis verbs we'll be going over:\n\n* filter()\n* select()\n* arrange()\n* mutate()\n* summarize() plus group_by()\n\nFirst, let's bring in the data.\n\n## Importing\n\n**We're going to play around with historical FEMA disaster declaration data.**\n\nFirst steps when analyzing data in R.\n\nBring in the appropriate packages.\n\nLet's start out with **tidyverse** which is a suite of packages that are consistently used to import, wrangle, and visualize data. It's one package that installs, like nearly a dozen other ones such as **readr**, **dplyr**, **tidyr** and **ggplot2**. The **lubridate** package is for dealing with dates.\n\nAnd we'll also need to bring the data in. \n\nYou can download it and import it locally, but if it's a csv, you can just link to it and R will download it for you in the function.\n\nUse the function from the **readr** package to import the csv from the URL. (This will take several moments to download, it's a big file)\n\n\n\n::: {.panel-tabset}\n\n## Exercise\n\n```{webr}\n#| exercise: ea1\nlibrary(dplyr)\nlibrary(readr)\nlibrary(lubridate)\n\n#https://www.fema.gov/openfema-data-page/disaster-declarations-summaries-v2\ndf <- ________(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n```\n\n\n## Hint\n\n::: { .hint exercise=\"ea1\"}\n\nfunction starts with an *r*.\ntwo words separated with a \"_\"\n\n:::\n\n## Solution\n\n::: { .solution exercise=\"ea1\"}\n\n\n```{webr importing-solution}\n#| exercise: ea1\n#| solution: true\nlibrary(dplyr)\nlibrary(readr)\nlibrary(lubridate)\n\n#https://www.fema.gov/openfema-data-page/disaster-declarations-summaries-v2\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n```\n\n\n```{webr importing-grade}\n#| exercise: ea1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n:::::\n\n\n## Exploring steps\n\nWhat to do when you first get a data set? Poke around and see what you're working with.\n\nUse the function on the **df** object you imported into your R environment.\n\nWe want to look at all the columns available to work with in the data. In Excel, you could just open up the file and click and scroll around but this time we want to do it within the R environment.\n\n\n::: {.panel-tabset}\n\n## Exercise\n\n```{webr glimpse}\n#| exercise: glimpse\n________df_\n```\n\n\n## Hint\n\n::: { .hint exercise=\"glimpse\"}\nStarts with a *g*\nAlso, don't forget that functions need parentheses.\n:::\n\n## Solution\n\n::: { .solution exercise=\"glimpse\"}\n\n```{webr glimpse-solution}\n#| exercise: glimpse\n#| solution: true\nglimpse(df)\n```\n\n```{webr glimpse-check}\n#| exercise: glimpse\n#| check: true\ngradethis::grade_this_code()\n```\n\n\n:::\n\n::::\n\n\n## Range\n\nAlright, we know that there are 28 different columns and more than 67,000 rows (each one a different disaster declaration) in this data set. That's a lot to work with!\n\nWe also see in the `<>` what type of data is within each of the columns (you can't mix).\n\n* `<chr>` for characters or strings\n* `<dbl>` for numbers\n* `<dttm>` for date times\n\nSo `glimpse()` only gave us a sample of the first few values in each column. \n\nNext, we can drill down into individual columns we're interested in.\n\n**incidentBeginDate** could be useful if we want to track incidents overtime.\n\nWe should check how far back and how recent the incidents are.\n\nUse a function on the **df** object to determine the range of dates for incidents.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr range}\n#| exercise: range\n_____df_incidentBeginDate_\n```\n\n## Hint\n::: { .hint excerise=\"range}\nfunction starts with an *r*.\nAlso, in Base R, to focus on a single column in a data frame, \nyou need a dollar sign between the data frame name and column name\n:::\n\n## Solution\n\n::: { .solution exercise=\"range\"}\n```{webr range-solution}\n#| exercise: range\n#| solution: true\nrange(df$incidentBeginDate)\n```\n\n\n```{webr range-check}\n#| exercise: range\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n::::\n\n## Table\n\nDid any other columns catch your eye?\n\nHopefully **incidentType** did. \n\nLet's next get a sense of what type of disasters are listed in this data set.\n\nIn Base R, the quick way to do this is to use the function `table()` around a column and data frame.\n\nTry using the function below on the column `incidentType`\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr types}\n#| exercise: types\n### Using base R\ntable(df_____________)\n\n```\n\n## Hint\n\n::: { .hint exercise=\"types\"}\nIn Base R, you need a special character between the data frame name and column name\n:::\n\n## Solution\n\n::: { .solution exercise=\"types\"}\n```{webr types-solution}\n#| exercise: types\n#| solution: true\ntable(df$incidentType)\n```\n\n\n```{webr types-check}\n#| exercise: types\n#| check: true\ngradethis::grade_this_code()\n```\n\n\n:::\n::::\n\n## Count\n\nAlright, you can see Biological, Chemical, Coastal Storm, etc...\n\nIt might take sometime to figure out which is the most... Since it's ordered alphabetical.\n\nSo `table()` is a quick exploratory command from Base R but if you want to save it as a dataframe, then the **dplyr** method is better. \n\nUse the `count()` function on **df**. Because we're using a function from the **dplyr** library, which is part of the tidyverse suite of packages, then we don't need to use a `$` to focus on the specific column `incidentType`.\n\nThe function is structured so that the first argument in the function is always the data frame and second one is the column in the data frame, separated with a comma.\n\nTry the `count()` function here on the `incidentType` column of **df**.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr count}\n#| exercise: count\nincident_types <- _____(df, _________)\n\nincident_types\n```\n\n## Hint\n\n::: { .hint exercise=\"count\"}\nThese are how tidy functions are structured:\nfunction_name(dataframe_name, column_name)\n:::\n\n## Solution\n\n::: { .solution exercise=\"count\"}\n\n```{webr count-solution}\n#| exercise: count\n#| solution: true\nincident_types <- count(df, incidentType)\n\nincident_types\n```\n\n\n```{webr count-check}\n#| exercise: count\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n::::\n\n\nOkay, great. The default new column is named \"n\".\n\nWe can change that by adding an extra argument to the `count()` function: `name=\"name_of_column\"`\n\nFill out the code below but call the new column you're creating \"total\".\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr count2}\n#| exercise: count2\nincident_types <- _____(df, _________, name=\"______\")\n\nincident_types\n```\n\n## Hint\n\n::: { .hint exercise=\"count2\"}\nYou're passing it a string so make sure the \ncolumn name is in between quotation marks\n:::\n\n## Solution\n\n::: { .solution exercise=\"count2\"}\n```{webr count2-solution}\n#| exercise: count2\n#| solution: true\nincident_types <- count(df, incidentType, name=\"total\")\n\nincident_types\n```\n\n\n```{webr count2-check}\n#| exercise: count2\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n\n::::\n\n## Arrange\n\nGreat! Now we're looking at table instead of a cluster of incident types.\n\nThis is much easier to scan.\n\nBut we're still dealing with alphabetically sorted incidents. \n\nWe need to look at which disaster types have occurred most often over time.\n\nWe're going to use a new function called `arrange()`\n\nWe have the new object data frame with the counts of incidents that you called **incident_types**.\n\nWe just need to use the `arrange()` function on the dataframe, specifically the new column you created called `total`.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr arrange}\n#| exercise: arrange\nincident_types_arranged <- arrange(__________, _____)\n\nincident_types_arranged\n```\n\n## Hint\n\n::: { .hint exercise=\"arrange\"}\nIs your first argument in arrange() the name of the \nnewer dataframe you created using count()?\n  \nAlso, you don't need to put \"total\" in quotation marks this time!\nBecause column names aren't strings. They're objects.\n:::\n\n## Solution\n\n::: { .solution exercise=\"arrange}\n```{webr arrange-solution}\n#| exercise: arrange\n#| solution: true\nincident_types_arranged <- arrange(incident_types, total)\n\nincident_types_arranged\n```\n\n```{webr arrange-check}\n#| exercise: arrange\n#| check: true\ngrade_this_code()\n```\n\n:::\n\n::::\n\n### Arrange descending\n\nOkay, this isn't what we wanted. This is going in ascending order, aka, least to most.\n\nWe need most to least!\n\nSo we need to adjust the `arrange()` function with the `desc()` function wrapped around the column you're sorting on. \n\nYou're nesting functions.\n\nAdjust your code from before but use the `desc()` formula, too.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr arrange2}\n#| exercise: arrange2\nincident_types_arranged <- arrange(__________, ____(_____))\n\nincident_types_arranged\n```\n\n## Hint\n\n::: { .hint exercise=\"arrange2\"}\nIs your first argument in arrange() the name of the \nnewer dataframe you created using count()?\n  \nAlso, you don't need to put \"total\" in quotation marks this time!\nBecause column names aren't strings. They're objects.\n:::\n\n## Solution\n\n::: { .solution exercise=\"arrange2\"}\n\n```{webr arrange2-solution}\n#| exercise: arrange2\n#| solution: true\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nincident_types_arranged\n```\n\n\n```{webr arrange2-check}\n#| exercise: arrange2\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n\n::::\n\n\nGreat job!\n\nWe see that Severe Storms are the most-common disaster types declared.\n\nThen, hurricanes and floods.\n\n## Pipes\n\nPipes is `|>` which represents \"and then.\"\n\nIt allows you to daisy chain functions to transform data in a more readable format. It's very popular and more languages are implementing it. It works only if a function is structured in a way that the first argument is always the dataframe it's altering. For example:\n\n\n![](images/pipe.png)\n\nHere's the code that got you to this point:\n\n```{r eval=F}\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n```\n\n## Without Pipes\n\n```{webr}\ncounted <- count(df, state, name=\"disasters\")\nsorted_count <- arrange(counted, desc(disasters))\n\nsorted_count\n```\n\n## With Pipes\n\n```{webr}\nsorted_pipes <- df |> \n  count(state, name=\"disasters\") |> \n  arrange(desc(disasters))\n\nsorted_pipes\n```\n","srcMarkdownNoYaml":"\n\n\n{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}\n{{< include ../_extensions/r-wasm/live/_gradethis.qmd >}}\n\n\n```{webr}\n#| include: false\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nfloods <- df |> filter(incidentType==\"Flood\")\nfloods_adjusted <- floods |> \n  mutate(year=year(declarationDate))\nfloods_match <- floods_adjusted |> \n  mutate(year_match=\n           case_when(year==fyDeclared ~ \"Match\",\n                     TRUE ~ \"Not a match\"\n  )) |> \n  group_by(year_match) |> \n  summarize(total=n())\nfloods_match_count <- floods_match |> \n  filter(year_match==\"Not a match\") |> \n  pull(total)\n```\n\n\n```{webr 3}\n#| edit: false\n#| output: false\n#| define:\n#|   - ok_reponse\nlibrary(htmltools)\nok_reponse <- function(reponse, n) {\n  if (is.na(reponse)) HTML(\"\")\n  else if (reponse == n) div(HTML(\"Correct ✓\"), style = \"color: green\")\n  else div(HTML(\"Incorrect ✗\"), style = \"color: red\")\n}\n```\n\n## Intro\n\n\nIn this lesson, we're going to start exploring data with the package **dplyr.**\n\n* It's designed to work with data frames, which is what journalists are used to\n* Great for data exploration and transformation\n* Intuitive to write and easy to read, especially when using the “chaining” syntax of pipes\n\nThese are the functions/data analysis verbs we'll be going over:\n\n* filter()\n* select()\n* arrange()\n* mutate()\n* summarize() plus group_by()\n\nFirst, let's bring in the data.\n\n## Importing\n\n**We're going to play around with historical FEMA disaster declaration data.**\n\nFirst steps when analyzing data in R.\n\nBring in the appropriate packages.\n\nLet's start out with **tidyverse** which is a suite of packages that are consistently used to import, wrangle, and visualize data. It's one package that installs, like nearly a dozen other ones such as **readr**, **dplyr**, **tidyr** and **ggplot2**. The **lubridate** package is for dealing with dates.\n\nAnd we'll also need to bring the data in. \n\nYou can download it and import it locally, but if it's a csv, you can just link to it and R will download it for you in the function.\n\nUse the function from the **readr** package to import the csv from the URL. (This will take several moments to download, it's a big file)\n\n\n\n::: {.panel-tabset}\n\n## Exercise\n\n```{webr}\n#| exercise: ea1\nlibrary(dplyr)\nlibrary(readr)\nlibrary(lubridate)\n\n#https://www.fema.gov/openfema-data-page/disaster-declarations-summaries-v2\ndf <- ________(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n```\n\n\n## Hint\n\n::: { .hint exercise=\"ea1\"}\n\nfunction starts with an *r*.\ntwo words separated with a \"_\"\n\n:::\n\n## Solution\n\n::: { .solution exercise=\"ea1\"}\n\n\n```{webr importing-solution}\n#| exercise: ea1\n#| solution: true\nlibrary(dplyr)\nlibrary(readr)\nlibrary(lubridate)\n\n#https://www.fema.gov/openfema-data-page/disaster-declarations-summaries-v2\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n```\n\n\n```{webr importing-grade}\n#| exercise: ea1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n:::::\n\n\n## Exploring steps\n\nWhat to do when you first get a data set? Poke around and see what you're working with.\n\nUse the function on the **df** object you imported into your R environment.\n\nWe want to look at all the columns available to work with in the data. In Excel, you could just open up the file and click and scroll around but this time we want to do it within the R environment.\n\n\n::: {.panel-tabset}\n\n## Exercise\n\n```{webr glimpse}\n#| exercise: glimpse\n________df_\n```\n\n\n## Hint\n\n::: { .hint exercise=\"glimpse\"}\nStarts with a *g*\nAlso, don't forget that functions need parentheses.\n:::\n\n## Solution\n\n::: { .solution exercise=\"glimpse\"}\n\n```{webr glimpse-solution}\n#| exercise: glimpse\n#| solution: true\nglimpse(df)\n```\n\n```{webr glimpse-check}\n#| exercise: glimpse\n#| check: true\ngradethis::grade_this_code()\n```\n\n\n:::\n\n::::\n\n\n## Range\n\nAlright, we know that there are 28 different columns and more than 67,000 rows (each one a different disaster declaration) in this data set. That's a lot to work with!\n\nWe also see in the `<>` what type of data is within each of the columns (you can't mix).\n\n* `<chr>` for characters or strings\n* `<dbl>` for numbers\n* `<dttm>` for date times\n\nSo `glimpse()` only gave us a sample of the first few values in each column. \n\nNext, we can drill down into individual columns we're interested in.\n\n**incidentBeginDate** could be useful if we want to track incidents overtime.\n\nWe should check how far back and how recent the incidents are.\n\nUse a function on the **df** object to determine the range of dates for incidents.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr range}\n#| exercise: range\n_____df_incidentBeginDate_\n```\n\n## Hint\n::: { .hint excerise=\"range}\nfunction starts with an *r*.\nAlso, in Base R, to focus on a single column in a data frame, \nyou need a dollar sign between the data frame name and column name\n:::\n\n## Solution\n\n::: { .solution exercise=\"range\"}\n```{webr range-solution}\n#| exercise: range\n#| solution: true\nrange(df$incidentBeginDate)\n```\n\n\n```{webr range-check}\n#| exercise: range\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n::::\n\n## Table\n\nDid any other columns catch your eye?\n\nHopefully **incidentType** did. \n\nLet's next get a sense of what type of disasters are listed in this data set.\n\nIn Base R, the quick way to do this is to use the function `table()` around a column and data frame.\n\nTry using the function below on the column `incidentType`\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr types}\n#| exercise: types\n### Using base R\ntable(df_____________)\n\n```\n\n## Hint\n\n::: { .hint exercise=\"types\"}\nIn Base R, you need a special character between the data frame name and column name\n:::\n\n## Solution\n\n::: { .solution exercise=\"types\"}\n```{webr types-solution}\n#| exercise: types\n#| solution: true\ntable(df$incidentType)\n```\n\n\n```{webr types-check}\n#| exercise: types\n#| check: true\ngradethis::grade_this_code()\n```\n\n\n:::\n::::\n\n## Count\n\nAlright, you can see Biological, Chemical, Coastal Storm, etc...\n\nIt might take sometime to figure out which is the most... Since it's ordered alphabetical.\n\nSo `table()` is a quick exploratory command from Base R but if you want to save it as a dataframe, then the **dplyr** method is better. \n\nUse the `count()` function on **df**. Because we're using a function from the **dplyr** library, which is part of the tidyverse suite of packages, then we don't need to use a `$` to focus on the specific column `incidentType`.\n\nThe function is structured so that the first argument in the function is always the data frame and second one is the column in the data frame, separated with a comma.\n\nTry the `count()` function here on the `incidentType` column of **df**.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr count}\n#| exercise: count\nincident_types <- _____(df, _________)\n\nincident_types\n```\n\n## Hint\n\n::: { .hint exercise=\"count\"}\nThese are how tidy functions are structured:\nfunction_name(dataframe_name, column_name)\n:::\n\n## Solution\n\n::: { .solution exercise=\"count\"}\n\n```{webr count-solution}\n#| exercise: count\n#| solution: true\nincident_types <- count(df, incidentType)\n\nincident_types\n```\n\n\n```{webr count-check}\n#| exercise: count\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n::::\n\n\nOkay, great. The default new column is named \"n\".\n\nWe can change that by adding an extra argument to the `count()` function: `name=\"name_of_column\"`\n\nFill out the code below but call the new column you're creating \"total\".\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr count2}\n#| exercise: count2\nincident_types <- _____(df, _________, name=\"______\")\n\nincident_types\n```\n\n## Hint\n\n::: { .hint exercise=\"count2\"}\nYou're passing it a string so make sure the \ncolumn name is in between quotation marks\n:::\n\n## Solution\n\n::: { .solution exercise=\"count2\"}\n```{webr count2-solution}\n#| exercise: count2\n#| solution: true\nincident_types <- count(df, incidentType, name=\"total\")\n\nincident_types\n```\n\n\n```{webr count2-check}\n#| exercise: count2\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n\n::::\n\n## Arrange\n\nGreat! Now we're looking at table instead of a cluster of incident types.\n\nThis is much easier to scan.\n\nBut we're still dealing with alphabetically sorted incidents. \n\nWe need to look at which disaster types have occurred most often over time.\n\nWe're going to use a new function called `arrange()`\n\nWe have the new object data frame with the counts of incidents that you called **incident_types**.\n\nWe just need to use the `arrange()` function on the dataframe, specifically the new column you created called `total`.\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr arrange}\n#| exercise: arrange\nincident_types_arranged <- arrange(__________, _____)\n\nincident_types_arranged\n```\n\n## Hint\n\n::: { .hint exercise=\"arrange\"}\nIs your first argument in arrange() the name of the \nnewer dataframe you created using count()?\n  \nAlso, you don't need to put \"total\" in quotation marks this time!\nBecause column names aren't strings. They're objects.\n:::\n\n## Solution\n\n::: { .solution exercise=\"arrange}\n```{webr arrange-solution}\n#| exercise: arrange\n#| solution: true\nincident_types_arranged <- arrange(incident_types, total)\n\nincident_types_arranged\n```\n\n```{webr arrange-check}\n#| exercise: arrange\n#| check: true\ngrade_this_code()\n```\n\n:::\n\n::::\n\n### Arrange descending\n\nOkay, this isn't what we wanted. This is going in ascending order, aka, least to most.\n\nWe need most to least!\n\nSo we need to adjust the `arrange()` function with the `desc()` function wrapped around the column you're sorting on. \n\nYou're nesting functions.\n\nAdjust your code from before but use the `desc()` formula, too.\n\n\n::: { .panel-tabset}\n\n## Exercise\n\n```{webr arrange2}\n#| exercise: arrange2\nincident_types_arranged <- arrange(__________, ____(_____))\n\nincident_types_arranged\n```\n\n## Hint\n\n::: { .hint exercise=\"arrange2\"}\nIs your first argument in arrange() the name of the \nnewer dataframe you created using count()?\n  \nAlso, you don't need to put \"total\" in quotation marks this time!\nBecause column names aren't strings. They're objects.\n:::\n\n## Solution\n\n::: { .solution exercise=\"arrange2\"}\n\n```{webr arrange2-solution}\n#| exercise: arrange2\n#| solution: true\nincident_types_arranged <- arrange(incident_types, desc(total))\n\nincident_types_arranged\n```\n\n\n```{webr arrange2-check}\n#| exercise: arrange2\n#| check: true\ngradethis::grade_this_code()\n```\n\n:::\n\n::::\n\n\nGreat job!\n\nWe see that Severe Storms are the most-common disaster types declared.\n\nThen, hurricanes and floods.\n\n## Pipes\n\nPipes is `|>` which represents \"and then.\"\n\nIt allows you to daisy chain functions to transform data in a more readable format. It's very popular and more languages are implementing it. It works only if a function is structured in a way that the first argument is always the dataframe it's altering. For example:\n\n\n![](images/pipe.png)\n\nHere's the code that got you to this point:\n\n```{r eval=F}\ndf <- read_csv(\"https://www.fema.gov/api/open/v2/DisasterDeclarationsSummaries.csv\")\n\nincident_types <- count(df, incidentType, name=\"total\")\nincident_types_arranged <- arrange(incident_types, desc(total))\n```\n\n## Without Pipes\n\n```{webr}\ncounted <- count(df, state, name=\"disasters\")\nsorted_count <- arrange(counted, desc(disasters))\n\nsorted_count\n```\n\n## With Pipes\n\n```{webr}\nsorted_pipes <- df |> \n  count(state, name=\"disasters\") |> \n  arrange(desc(disasters))\n\nsorted_pipes\n```\n"},"formats":{"live-html":{"identifier":{"display-name":"HTML","target-format":"live-html","base-format":"html","extension-name":"live"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["/Users/andrewtran/Projects/chjr/_extensions/r-wasm/live/live.lua"],"output-file":"explore_arrange.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","ojs-engine":true,"revealjs-plugins":[],"theme":{"light":"cosmo","dark":"darkly"},"title":"Exploring, arrange, count","webr":{"packages":["readr","dplyr","lubridate","gradethis"]},"resources":["images"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}